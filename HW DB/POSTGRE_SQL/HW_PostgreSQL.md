# В PostgreSQL
## Создаём БД

Создаем БД `PlasticOrder`

``` 
CREATE database "PlasticOrder"
	WITH owner = postgres
    ENCODING   = 'UTF-8'
    ;
-- предварительно переключиться на созданную БД
CREATE SCHEMA IF NOT EXISTS "dbo";

SHOW search_path; -- смотрим на пути

SET search_path TO dbo, public ; -- добавляем новую схему
```
## Различие типов данных (символьные типы)

В PostgreSQL тип `nvarchar` не существует
`varchar(n)` - строка ограниченной переменной длины
`char(n)`	- строка фиксированной длины, дополненная пробелами
Типы `char` и `varchar` не рекомендуется использовать по дефолту т.к. при отсутствии выигрыша в размере есть риск, что ширины не хватит под вводимое значение

`varchar(n)` имеет смысл использовать только если нужно текстовое поле, которое выдаст ошибку при вставке слишком длинной длиной - более n символов (не байтов) - строки.

PostgreSQL предлагает тип `text`, в котором можно хранить строки произвольной длины., 
т.к. все эти символьные типы занимают одинаковое количество места, при отутствии разницы в производительности, использование `text` предпочтительнее,
а т.к. `text` не описан в стандарте SQL я буду использовать тип `varchar` без указания длины, что допускается документацией PostgreSQL гл. 8.3.

> Цитата с Хабра:
>
> *Разница только в декларации намерений. Используя TEXT, мы декларируем намерение хранить «длинные тексты».
> А используя varchar, мы декларируем намерение хранить «короткие строки». Причем разница между «длинным» и «коротким» субъективна.*

## Создаём структуру БД

```
--- создаем таблицу по образцу. почти :)

CREATE TABLE IF NOT EXISTS "dbo"."cardTypes"(
	"idCardType" SMALLINT NOT NULL,
	"idCardSystem" bigint NULL,
	"name" varchar NULL,
	CONSTRAINT "PK_cardType" PRIMARY KEY ("idCardType")
)
;

CREATE TABLE IF NOT EXISTS "dbo"."clients" (
  "idClient" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "firstName" varchar,
  "middleName" varchar,
  "surname" varchar,
  "birthday" date,
  "regAddress" varchar,
  "idDirStatus" SMALLINT, -- так как таблицы c PK ещё нет, FK допишем отдельно
  "createDate" date,
  "PIN_EQ" varchar
)
;

CREATE TABLE IF NOT EXISTS "dbo"."departments" (
  "idDepartment" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "name" varchar,
  "idDepartmentsSystem" bigint,
  "workTime" varchar,
  "phone" varchar,
  "adressString" varchar,
  "City" varchar,
  "Village" varchar,
  "Street" varchar,
  "Build" varchar,
  "SCNAME" varchar,
  "KLADR" bigint,
  "KLADR_STREET" bigint,
  CHECK ("KLADR">1000000000000 AND "KLADR"<9999999999999),
  CHECK ("KLADR_STREET">10000000000000000 AND "KLADR_STREET"<99999999999999999)
)
--- а потом я передумал т.к. не получится выбирать значения по LIKE '%'

	ALTER TABLE "dbo"."departments" DROP CONSTRAINT "departments_KLADR_STREET_check"
	ALTER TABLE "dbo"."departments" DROP CONSTRAINT "departments_KLADR_check"
	ALTER TABLE "dbo"."departments" ALTER COLUMN "KLADR" TYPE varchar(13)
	ALTER TABLE "dbo"."departments" ALTER COLUMN "KLADR_STREET" TYPE varchar(17)
;

CREATE TABLE IF NOT EXISTS "dbo"."dirChannels" (
  "idDirChannel" SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "name" varchar
)
;

CREATE TABLE IF NOT EXISTS "dbo"."dirStatuses" (
  "idDirStatus" SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "name" varchar
)
;

ALTER TABLE "dbo"."clients" ADD FOREIGN KEY ("idDirStatus") REFERENCES "dbo"."dirStatuses" ("idDirStatus")
-- если таблица клиентов заполнена, то сначала надо заполнить таблицу статусов
;

CREATE TABLE IF NOT EXISTS "dbo"."dirStatusesOrders" (
  "idDirStatusOrder" SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "name" varchar
)
;

CREATE TABLE IF NOT EXISTS "dbo"."orders" (
  "idOrder" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "idClient" bigint REFERENCES "dbo"."clients", -- наименования атрибутов совпадают, поэтому момжно явно не указывать
  "idDirChannel" SMALLINT REFERENCES "dbo"."dirChannels",
  "idCardType" SMALLINT REFERENCES "dbo"."cardTypes",
  "idDepartment" int REFERENCES "dbo"."departments",
  "idDirStatusOrder" SMALLINT REFERENCES "dbo"."dirStatusesOrders",
  "createDate" date,
  "editUser" bigint, -- так как таблицы c PK ещё нет, FK допишем отдельно 
  "updateDate" date
)
;

CREATE TABLE IF NOT EXISTS "dbo"."users" (
  "idUser" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "login" varchar
)
;
ALTER TABLE "dbo"."orders" ADD FOREIGN KEY ("editUser") REFERENCES "dbo"."users" ("idUser")
;

/* Описение полей */

COMMENT ON TABLE "dbo"."cardTypes" IS 'Тип Карты';
COMMENT ON COLUMN "dbo"."cardTypes"."idCardType" IS 'Тип Карты.';
COMMENT ON COLUMN "dbo"."cardTypes"."idCardSystem" IS 'Идентификатор в источнике данных';
COMMENT ON COLUMN "dbo"."cardTypes"."name" IS 'Наименование Карты';
	
COMMENT ON TABLE "dbo"."clients" IS 'Анкеты Клиентов';
COMMENT ON COLUMN "dbo"."clients"."idClient" IS 'Уникальный идентификатор.(8)';
COMMENT ON COLUMN "dbo"."clients"."firstName" IS 'Имя';
COMMENT ON COLUMN "dbo"."clients"."middleName" IS 'Отчество';
COMMENT ON COLUMN "dbo"."clients"."surname" IS 'Фамилия';
COMMENT ON COLUMN "dbo"."clients"."birthday" IS 'Дата рождения';
COMMENT ON COLUMN "dbo"."clients"."regAddress" IS 'Адрес регистрации';
COMMENT ON COLUMN "dbo"."clients"."idDirStatus" IS 'Статус.(2)';
COMMENT ON COLUMN "dbo"."clients"."createDate" IS 'Дата создания';
COMMENT ON COLUMN "dbo"."clients"."PIN_EQ" IS 'Идентификатор Клиента Банка. Заполняется для действующих клиентов.(6)';

COMMENT ON TABLE "dbo"."departments" IS 'Отделения выдачи Карт';
COMMENT ON COLUMN "dbo"."departments"."idDepartment" IS 'Идентификатор.(4)';
COMMENT ON COLUMN "dbo"."departments"."name" IS 'Наименование';
COMMENT ON COLUMN "dbo"."departments"."idDepartmentsSystem" IS 'Идентификатор в системе-источнике.(8)';
COMMENT ON COLUMN "dbo"."departments"."workTime" IS 'Время работы отделения Банка';
COMMENT ON COLUMN "dbo"."departments"."phone" IS 'Телефон отделения Банка';
COMMENT ON COLUMN "dbo"."departments"."adressString" IS 'Адрес Банка';

COMMENT ON TABLE "dbo"."dirChannels" IS 'Канал поступления Анкеты';
COMMENT ON COLUMN "dbo"."dirChannels"."idDirChannel" IS '[Первичный ключ.(2)';
COMMENT ON COLUMN "dbo"."dirChannels"."name" IS 'Наименование канала';

COMMENT ON TABLE "dbo"."dirStatuses" IS 'Статусы Анкет';
COMMENT ON COLUMN "dbo"."dirStatuses"."idDirStatus" IS 'Первичный ключ.(2)';
COMMENT ON COLUMN "dbo"."dirStatuses"."name" IS '(Наименование Статуса';

COMMENT ON TABLE "dbo"."dirStatusesOrders" IS 'Статусы Заявок';
COMMENT ON COLUMN "dbo"."dirStatusesOrders"."idDirStatusOrder" IS 'Первичный ключ.(2)';
COMMENT ON COLUMN "dbo"."dirStatusesOrders"."name" IS '(Наименование Статуса Заявки';

COMMENT ON TABLE "dbo"."orders" IS 'Таблица заказов Карт';
COMMENT ON COLUMN "dbo"."orders"."idOrder" IS 'Первичный ключ.(8)';
COMMENT ON COLUMN "dbo"."orders"."createDate" IS 'Дата создания Заказа';
COMMENT ON COLUMN "dbo"."orders"."editUser" IS 'Пользователь - Сотрудник Банка, кто вносил изменения.(8)';
COMMENT ON COLUMN "dbo"."orders"."updateDate" IS 'Дата обновления заказа';

COMMENT ON TABLE "dbo"."users" IS 'Пользователи Системы. Сотрудники Банка, кто имеет разрешение на редактирование Запросов и Анкет Клиента';
COMMENT ON COLUMN "dbo"."users"."idUser" IS 'Первичный ключ.(8)';
COMMENT ON COLUMN "dbo"."users"."login" IS 'Логин Пользователя.(10)';

```

## Убираем за собой
При необходимости
```
DROP SCHEMA IF EXISTS "dbo" CASCADE;

/* удаляем базу данных */

--- 1) смотрим подключения
SELECT * FROM pg_stat_activity; 
--- 2) подключаемся к другой БД
--- 3) отключить сессии через интерфейс terminate или перезайти в DBeaver
--- Иначе "SQL Error [55006]: ОШИБКА: удалить базу данных, открытую в данный момент, нельзя"

DROP database "PlasticOrder";

```
# В SQL Server Management Studio

## Заполняем таблицы значениями из БД

```
INSERT INTO
	[POSTGRESQL].[PlasticOrder].[dbo].[cardTypes]
SELECT
	idCardType,
	idCardSystem,
	IIF (name NOT LIKE '[А-Я]%',right (name,len(name)-2),name)
FROM
	[PlasticOrder].[dbo].[cardTypes]
;

--- Часть 1 -- используем TOP
INSERT INTO
	[POSTGRESQL].[PlasticOrder].[dbo].[clients]
SELECT top 10000 
	idClient,
	firstName,
	middleName,
	surname,
	birthday,
	regAddress,
	idDirStatus,
	createDate,
	PIN_EQ
FROM
	[PlasticOrder].[dbo].[clients]
;
--- Часть 2 -- используем OFFSET...FETCH
INSERT INTO
	[POSTGRESQL].[PlasticOrder].[dbo].[clients]
SELECT
	idClient,
	firstName,
	middleName,
	surname,
	birthday,
	regAddress,
	idDirStatus,
	createDate,
	PIN_EQ
FROM
	[PlasticOrder].[dbo].[clients]
ORDER BY idClient
    OFFSET 10000 ROWS
    FETCH NEXT 10000 ROWS ONLY
;
--- Часть 3
INSERT INTO
	[POSTGRESQL].[PlasticOrder].[dbo].[clients] 
SELECT
	idClient,
	firstName,
	middleName,
	surname,
	birthday,
	regAddress,
	idDirStatus,
	createDate,
	PIN_EQ
FROM
	[PlasticOrder].[dbo].[clients]
ORDER BY idClient 
    OFFSET 20000 ROWS
    FETCH NEXT 10000 ROWS ONLY
;
--- Часть 4
INSERT INTO
	[POSTGRESQL].[PlasticOrder].[dbo].[clients]
SELECT
	idClient,
	firstName,
	middleName,
	surname,
	birthday,
	regAddress,
	idDirStatus,
	createDate,
	PIN_EQ
FROM
	[PlasticOrder].[dbo].[clients]	
ORDER BY idClient 
    OFFSET 30000 ROWS
    FETCH NEXT 10000 ROWS ONLY
;
--- Часть 5
INSERT INTO
	[POSTGRESQL].[PlasticOrder].[dbo].[clients]
SELECT
	idClient,
	firstName,
	middleName,
	surname,
	birthday,
	regAddress,
	idDirStatus,
	createDate,
	PIN_EQ
FROM
	[PlasticOrder].[dbo].[clients]	
ORDER BY idClient 
    OFFSET 40000 ROWS
    FETCH NEXT 10000 ROWS ONLY
;

INSERT INTO [POSTGRESQL].[PlasticOrder].[dbo].[departments]
SELECT
	idDepartment,
	name,
	idDepartmentsSystem,
	workTime,
	phone,
	addressString,
	City,
	Village,
	Street,
	Build,
	SCNAME,
	KLADR,
	KLADR_STREET
--	В целевой таблицке KLADR и KLADR_STREET хранятся как целочисленные значения
FROM
	[PlasticOrder].[dbo].[departments]
;

INSERT INTO
	[POSTGRESQL].[PlasticOrder].[dbo].[dirChannels]
SELECT
	idDirChannel,
	name
FROM
	[PlasticOrder].[dbo].[dirChannels]
;

INSERT INTO [POSTGRESQL].[PlasticOrder].[dbo].[dirStatuses]
SELECT
	idDirStatus,
	name
FROM
	[PlasticOrder].[dbo].[dirStatuses]
;

INSERT INTO [POSTGRESQL].[PlasticOrder].[dbo].[dirStatusesOrders]
SELECT
	idDirStatusOrder,
	name
FROM
	[PlasticOrder].[dbo].[dirStatusesOrders]
;

/* Анкет тоже много, поэтому тоже загружаем кусками */
--- Часть 1 ---
INSERT INTO [POSTGRESQL].[PlasticOrder].[dbo].[orders] 
SELECT top 10000
	idOrder,
	idClient,
	idDirChannel,
	idCardType,
	idDepartment,
	idDirStatusOrder,
	createDate,
	editUser,
	updateDate
FROM
	[PlasticOrder].[dbo].[orders]
;
--- Часть 2 ---
INSERT INTO [POSTGRESQL].[PlasticOrder].[dbo].[orders] 
SELECT
	idOrder,
	idClient,
	idDirChannel,
	idCardType,
	idDepartment,
	idDirStatusOrder,
	createDate,
	editUser,
	updateDate
FROM
	[PlasticOrder].[dbo].[orders]
ORDER BY idOrder
    OFFSET 10000 ROWS
    FETCH NEXT 10000 ROWS ONLY
;
--- Часть 3 ---
INSERT INTO [POSTGRESQL].[PlasticOrder].[dbo].[orders] 
SELECT
	idOrder,
	idClient,
	idDirChannel,
	idCardType,
	idDepartment,
	idDirStatusOrder,
	createDate,
	editUser,
	updateDate
FROM
	[PlasticOrder].[dbo].[orders]
ORDER BY idOrder
    OFFSET 20000 ROWS
    FETCH NEXT 10000 ROWS ONLY
;
--- Часть 4 ---
INSERT INTO [POSTGRESQL].[PlasticOrder].[dbo].[orders] 
SELECT
	idOrder,
	idClient,
	idDirChannel,
	idCardType,
	idDepartment,
	idDirStatusOrder,
	createDate,
	editUser,
	updateDate
FROM
	[PlasticOrder].[dbo].[orders]
ORDER BY idOrder
    OFFSET 30000 ROWS
    FETCH NEXT 10000 ROWS ONLY
;
--- Часть 5 ---
INSERT INTO [POSTGRESQL].[PlasticOrder].[dbo].[orders] 
SELECT
	idOrder,
	idClient,
	idDirChannel,
	idCardType,
	idDepartment,
	idDirStatusOrder,
	createDate,
	editUser,
	updateDate
FROM
	[PlasticOrder].[dbo].[orders]
ORDER BY idOrder
    OFFSET 40000 ROWS
    FETCH NEXT 10000 ROWS ONLY
;

INSERT INTO [POSTGRESQL].[PlasticOrder].[dbo].[users]
SELECT
	idUser,
	login
FROM
	[PlasticOrder].[dbo].[users]
;

```
